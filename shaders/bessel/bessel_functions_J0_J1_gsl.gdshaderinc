// ====== ========== ====== //
// ====== Adaptation of GSL bessel J ====== //
// ====== ========== ====== //
/* Documentation on GSL - GNU scientific library:
*   https://www.gnu.org/software/gsl/doc/html/index.html
* To get the base code in C, go to : https://www.gnu.org/software/gsl/
*/

#include "res://shaders/bessel/bessel_cheb_poly_res.gdshaderinc"


// ====== J0 ====== //

const float bj0_data[30] = {
	0.100254161968939137,
	-0.665223007764405132,
	0.248983703498281314,
	-0.0332527231700357697,
	0.0023114179304694015,
	-0.0000991127741995080,
	0.0000028916708643998,
	-0.0000000612108586630,
	0.0000000009838650793,
	-0.0000000000124235515,
	0.0000000000001265433,
	-0.0000000000000010619,
	0.0000000000000000074,
	0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
};
const cheb_series_type bj0_cs = cheb_series_type(
  bj0_data,
  12,
  -1.0, 1.0
  //9
);

const float bm0_data[30] = {
    0.09284961637381644,
   -0.00142987707403484,
    0.00002830579271257,
   -0.00000143300611424,
    0.00000012028628046,
   -0.00000001397113013,
    0.00000000204076188,
   -0.00000000035399669,
    0.00000000007024759,
   -0.00000000001554107,
    0.00000000000376226,
   -0.00000000000098282,
    0.00000000000027408,
   -0.00000000000008091,
    0.00000000000002511,
   -0.00000000000000814,
    0.00000000000000275,
   -0.00000000000000096,
    0.00000000000000034,
   -0.00000000000000012,
    0.00000000000000004,
    0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
};
const cheb_series_type _gsl_sf_bessel_amp_phase_bm0_cs = cheb_series_type(
    bm0_data,
    20,
    -1.0,
    1.0
);

const float bth0_data[30] = {
    -0.24639163774300119,
    0.001737098307508963,
    -0.000062183633402968,
    0.000004368050165742,
    -0.000000456093019869,
    0.000000062197400101,
    -0.000000010300442889,
    0.000000001979526776,
    -0.000000000428198396,
    0.000000000102035840,
    -0.000000000026363898,
    0.000000000007297935,
    -0.000000000002144188,
    0.000000000000663693,
    -0.000000000000215126,
    0.000000000000072659,
    -0.000000000000025465,
    0.000000000000009229,
    -0.000000000000003448,
    0.000000000000001325,
    -0.000000000000000522,
    0.000000000000000210,
    -0.000000000000000087,
    0.000000000000000036,
    0.0,0.0,0.0,0.0,0.0,0.0
};
const cheb_series_type _gsl_sf_bessel_amp_phase_bth0_cs = cheb_series_type(
    bth0_data,
    23,
    -1.0, 1.0
);

float gsl_sf_bessel_J0(const float x) {
	float val;
	float err;
	// ---
	float y = abs(x);
	if(y < 2.0*GSL_SQRT_DBL_EPSILON) {
		val = 1.0;
		//err = y*y;
		return val;
	}
	else if(y <= 4.0) {
		val = cheb_series(bj0_cs, 0.125*y*y - 1.0);
		return val;
	} else {
		float z = 32.0/(y*y) - 1.0;
		float ca = cheb_series(_gsl_sf_bessel_amp_phase_bm0_cs,  z);
		float ct = cheb_series(_gsl_sf_bessel_amp_phase_bth0_cs, z);
		float cp = gsl_sf_bessel_cos_pi4_e(y, ct/y);
		float sqrty = sqrt(y);
		float ampl  = (0.75 + ca) / sqrty;
		val  = ampl * cp;
		//err  = fabs(cp) * ca.err/sqrty + fabs(ampl) * cp.err;
		//result->err += GSL_DBL_EPSILON * fabs(result->val);
		return val;
	}
}

// ====== J1 ====== //
#define M_SQRT2    1.41421356237309504880168872421      /* sqrt(2) */
#define ROOT_EIGHT (2.0*M_SQRT2)
#define GSL_DBL_MIN 2.2250738585072014e-308

const float bj1_data[30] = {
  -0.11726141513332787,
  -0.25361521830790640,
   0.050127080984469569,
  -0.004631514809625081,
   0.000247996229415914,
  -0.000008678948686278,
   0.000000214293917143,
  -0.000000003936093079,
   0.000000000055911823,
  -0.000000000000632761,
   0.000000000000005840,
  -0.000000000000000044,
	0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
};
const cheb_series_type bj1_cs = cheb_series_type(
  bj1_data,
  11,
  -1.0, 1.0//,
  //8
);

const float bm1_data[30] = {
   0.1047362510931285, 
   0.00442443893702345,
  -0.00005661639504035,
   0.00000231349417339,
  -0.00000017377182007,
   0.00000001893209930,
  -0.00000000265416023,
   0.00000000044740209,
  -0.00000000008691795,
   0.00000000001891492,
  -0.00000000000451884,
   0.00000000000116765,
  -0.00000000000032265,
   0.00000000000009450,
  -0.00000000000002913,
   0.00000000000000939,
  -0.00000000000000315,
   0.00000000000000109,
  -0.00000000000000039,
   0.00000000000000014,
  -0.00000000000000005,
0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
}; 
const cheb_series_type _gsl_sf_bessel_amp_phase_bm1_cs = cheb_series_type(
	bm1_data,
	20,
	-1.0, 1.0//,
	//10
);

const float bth1_data[30] = {
   0.74060141026313850, 
  -0.004571755659637690,
   0.000119818510964326,
  -0.000006964561891648,
   0.000000655495621447,
  -0.000000084066228945,
   0.000000013376886564,
  -0.000000002499565654,
   0.000000000529495100,
  -0.000000000124135944,
   0.000000000031656485,
  -0.000000000008668640,
   0.000000000002523758,
  -0.000000000000775085,
   0.000000000000249527,
  -0.000000000000083773,
   0.000000000000029205,
  -0.000000000000010534,
   0.000000000000003919,
  -0.000000000000001500,
   0.000000000000000589,
  -0.000000000000000237,
   0.000000000000000097,
  -0.000000000000000040,
0.0,0.0,0.0,0.0,0.0,0.0
};
const cheb_series_type _gsl_sf_bessel_amp_phase_bth1_cs = cheb_series_type(
	bth1_data,
	23,
	-1.0, 1.0//,
	//12
);

float gsl_sf_bessel_J1(const float x) {
	float val;
	float err;
	// ---
	float y = abs(x);
	if(y == 0.0) {
		val = 0.0;
		err = 0.0;
		return val;
	}
	else if(y < 2.0*GSL_DBL_MIN) {
		//UNDERFLOW_ERROR(result); ???
		return 0.0;
	}
	else if(y < ROOT_EIGHT * GSL_SQRT_DBL_EPSILON) {
		val = 0.5*x;
		err = 0.0;
		return val;
	}
	else if(y < 4.0) {
		float c = cheb_series(bj1_cs, 0.125*y*y-1.0);
		val = x * (0.25 + c);
		//err = fabs(x * c.err);
		return val;
	} else {
		float z  = 32.0/(y*y) - 1.0;
		float ca = cheb_series(_gsl_sf_bessel_amp_phase_bm1_cs,  z);
		float ct = cheb_series(_gsl_sf_bessel_amp_phase_bth1_cs, z);
		float sp = gsl_sf_bessel_sin_pi4_e(y, ct/y);
		float sqrty = sqrt(y);
		float ampl  = (0.75 + ca) / sqrty;
		val  = (x < 0.0 ? -ampl : ampl) * sp;
		//err  = fabs(sp.val) * ca.err/sqrty + fabs(ampl) * sp.err;
		//err += GSL_DBL_EPSILON * fabs(result->val);
		return val;
	}
}
